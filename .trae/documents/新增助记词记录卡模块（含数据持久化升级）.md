明白了，那逻辑就更简单直接了！我们不需要做复杂的持久化（不需要存 LocalStorage），只需要在**当前会话内存**中维护这个状态即可。刷新网页或重新开始时，一切重置，保证记录的词与当前游戏的随机词一致。

修订后的计划如下：

### 1. 新增状态管理
*   在 `App.jsx` 中新增 `collectedWords` 状态，类型为对象或数组。
    *   初始值：`{}` （空对象）。
    *   **不需要**写入 `localStorage`，刷新即焚。

### 2. 游戏逻辑接入
*   修改 `handleSubmit`（提交答案函数）：
    *   当用户**答对**时：将 `currentLevel` 和对应的 `secretWord` 存入 `collectedWords`。
    *   *注意：如果用户切回已通关的旧关卡重玩并通关，会更新该关卡的记录（符合直觉，因为随机词变了）。*

### 3. UI 实现：助记词收集卡
*   **位置**：右侧边栏（`aside`），替换掉原来的“这一块后续补充”占位符。
*   **样式**：
    *   保持与上方计时器一致的视觉风格（圆角、阴影、半透明白底）。
    *   标题：“已破解助记词”。
    *   **网格布局**：展示 1 到 6 号位的卡槽。
    *   **显示逻辑**：
        *   如果 `collectedWords[i]` 有值 -> 显示该单词（粗体、高亮）。
        *   如果没值 -> 显示 `????` 或 `Locked`（灰色、模糊）。

### 4. 数据重置逻辑
*   检查代码中是否已经有“全局重置/重新开始”的按钮或逻辑。如果有，需要确保它会清空 `collectedWords`。如果没有，则默认依赖浏览器的刷新机制来清零。

这样设计既满足了“记录当前游戏进程”的需求，又避免了“旧记录与新随机词冲突”的问题。
